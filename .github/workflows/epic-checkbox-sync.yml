name: Sync EPIC checkboxes (close, reopen & route to Project)

on:
  issues:
    types: [edited]

env:
  ORG: ""                           # se vazio, usa o owner do repo
  PROJECT_NUMBER: "7"               # número do project (opcional se usar TITLE)
  PROJECT_TITLE: "Controle De Cinema"  # fallback por título (opcional, ajuda mto)
  MAP_CLOSED_JSON: >
    { "tipo:interface": "Pronto - Interface",
      "tipo:integracao": "Pronto - Integração",
      "tipo:unidade": "Pronto - Unidade",
      "default": "Pronto" }
  MAP_OPEN_JSON: >
    { "default": "Em Progresso" }
  ADD_IF_MISSING: "true"

jobs:
  sync:
    if: startsWith(github.event.issue.title, 'EPIC:') && github.event.changes.body != null
    runs-on: ubuntu-latest
    permissions:
      issues: write
      contents: read
    steps:
      - name: Close/Reopen & Move in Project
        uses: actions/github-script@v7
        with:
          # se a org bloquear acesso, use um PAT: github-token: ${{ secrets.WORKFLOW_PAT }}
          script: |
            const owner = context.repo.owner;
            const repo  = context.repo.repo;

            const before = context.payload.changes?.body?.from || '';
            const after  = context.payload.issue.body || '';

            const getChecked = (s) => {
              const re = /-\s*\[[xX]\]\s*#(\d+)/g;
              return new Set([...s.matchAll(re)].map(m => Number(m[1])));
            };

            const prev = getChecked(before);
            const curr = getChecked(after);

            const toClose = [...curr].filter(n => !prev.has(n));
            const toOpen  = [...prev].filter(n => !curr.has(n));
            const uniq = (arr) => [...new Set(arr)];

            const closedNow  = [];
            const reopenedNow = [];

            // 1) fechar
            for (const num of uniq(toClose)) {
              try {
                const { data } = await github.rest.issues.get({ owner, repo, issue_number: num });
                if (data.pull_request) { core.info(`#${num} é PR; ignore`); continue; }
                if (data.state !== 'closed') {
                  await github.rest.issues.update({ owner, repo, issue_number: num, state: 'closed' });
                }
                closedNow.push({ number: num, labels: (data.labels||[]).map(l => typeof l==='string'? l : l.name) });
                core.info(`Closed #${num}`);
              } catch (e) { core.warning(`Falha ao fechar #${num}: ${e.message}`); }
            }

            // 2) reabrir
            for (const num of uniq(toOpen)) {
              try {
                const { data } = await github.rest.issues.get({ owner, repo, issue_number: num });
                if (data.pull_request) { core.info(`#${num} é PR; ignore`); continue; }
                if (data.state !== 'open') {
                  await github.rest.issues.update({ owner, repo, issue_number: num, state: 'open' });
                }
                reopenedNow.push({ number: num, labels: (data.labels||[]).map(l => typeof l==='string'? l : l.name) });
                core.info(`Reopened #${num}`);
              } catch (e) { core.warning(`Falha ao reabrir #${num}: ${e.message}`); }
            }

            // 3) localizar Project v2 de forma resiliente
            const LOGIN = (process.env.ORG || '').trim() || owner;
            const PROJ_NUM_ENV = (process.env.PROJECT_NUMBER || '').trim();
            const PROJ_NUM = PROJ_NUM_ENV ? parseInt(PROJ_NUM_ENV, 10) : NaN;
            const PROJ_TITLE = (process.env.PROJECT_TITLE || '').trim();
            const ADD_IF_MISSING = process.env.ADD_IF_MISSING === "true";
            const MAP_CLOSED = JSON.parse(process.env.MAP_CLOSED_JSON || "{}");
            const MAP_OPEN   = JSON.parse(process.env.MAP_OPEN_JSON   || "{}");

            core.info(`Lookup Project for login='${LOGIN}' (number=${PROJ_NUM_ENV || 'n/a'}, title='${PROJ_TITLE || 'n/a'}')`);

            const listQuery = `
              query($login:String!) {
                organization(login:$login) { projectsV2(first:100) { nodes { id number title } } }
                user(login:$login)         { projectsV2(first:100) { nodes { id number title } } }
              }`;
            let all = [];
            try {
              const r = await github.graphql(listQuery, { login: LOGIN });
              const orgList  = r.organization?.projectsV2?.nodes || [];
              const userList = r.user?.projectsV2?.nodes || [];
              all = [...orgList, ...userList];
              core.info("Projects visíveis pelo token: " +
                (all.length ? all.map(p => `#${p.number}:${p.title}`).join(" | ") : "(nenhum)"));
            } catch (e) {
              core.setFailed(`Falha ao listar Projects v2 para '${LOGIN}': ${e.message}`);
              return;
            }

            let project = all.find(p => Number(p.number) === PROJ_NUM)
                       || (PROJ_TITLE ? all.find(p => p.title === PROJ_TITLE) : undefined);

            if (!project) {
              core.setFailed(
                `Project v2 não encontrado pelo token (login='${LOGIN}').\n` +
                `→ Confirme que o **repo está linkado** ao Project e que o número/título batem.\n` +
                `→ Vistos: ${all.map(p => `#${p.number}:${p.title}`).join(" | ") || "(nenhum)"}`
              );
              return;
            }
            core.info(`Project encontrado: #${project.number} ${project.title}`);

            // carregar campo Status e opções
            const fieldsQuery = `
              query($id:ID!) {
                node(id:$id) {
                  ... on ProjectV2 {
                    id title
                    fields(first:50) {
                      nodes {
                        ... on ProjectV2SingleSelectField {
                          id name
                          options { id name }
                        }
                      }
                    }
                  }
                }
              }`;
            const fr = await github.graphql(fieldsQuery, { id: project.id });
            const projNode = fr.node;
            const statusField = projNode.fields.nodes.find(f => f?.name === "Status");
            if (!statusField) { core.warning(`Campo 'Status' não encontrado em '${projNode.title}'`); return; }
            const optionIdByName = (name) => statusField.options.find(o => o.name === name)?.id;

            const issueItemQuery = `
              query($owner:String!, $repo:String!, $num:Int!) {
                repository(owner:$owner, name:$repo) {
                  issue(number:$num) {
                    id
                    projectItems(first:50) { nodes { id project { ... on ProjectV2 { id } } } }
                  }
                }
              }`;
            const addItemMutation = `
              mutation($projectId:ID!, $contentId:ID!) {
                addProjectV2ItemById(input:{projectId:$projectId, contentId:$contentId}) {
                  item { id }
                }
              }`;
            const updateMutation = `
              mutation($projectId:ID!, $itemId:ID!, $fieldId:ID!, $optionId:String!) {
                updateProjectV2ItemFieldValue(input:{
                  projectId:$projectId, itemId:$itemId, fieldId:$fieldId,
                  value:{ singleSelectOptionId:$optionId }
                }) { clientMutationId }
              }`;

            const setStatus = async (issueNumber, statusName) => {
              if (!statusName) return;
              const optId = optionIdByName(statusName);
              if (!optId) { core.warning(`Opção '${statusName}' não existe em Status`); return; }

              const res = await github.graphql(issueItemQuery, { owner, repo, num: issueNumber });
              const issueId = res.repository?.issue?.id;
              let item = res.repository?.issue?.projectItems?.nodes?.find(n => n.project?.id === project.id);
              if (!item) {
                if (!ADD_IF_MISSING) { core.info(`#${issueNumber} não está no Project; ignorando`); return; }
                const added = await github.graphql(addItemMutation, { projectId: project.id, contentId: issueId });
                item = added.addProjectV2ItemById.item;
                core.info(`#${issueNumber} adicionado ao Project '${projNode.title}'`);
              }

              await github.graphql(updateMutation, {
                projectId: project.id,
                itemId: item.id,
                fieldId: statusField.id,
                optionId: optId
              });
              core.info(`Status de #${issueNumber} → '${statusName}' atualizado.`);
            };

            const pickStatus = (labels, map) => {
              for (const l of labels || []) if (map[l]) return map[l];
              return map.default;
            };

            for (const it of closedNow)  { await setStatus(it.number, pickStatus(it.labels, MAP_CLOSED)); }
            for (const it of reopenedNow){ await setStatus(it.number, pickStatus(it.labels, MAP_OPEN)); }
