name: Sync EPIC checkboxes (close, reopen & route to Project)

on:
  issues:
    types: [edited]

env:
  # Se deixar vazio, usa automaticamente o owner do repo (context.repo.owner)
  ORG: ""
  PROJECT_NUMBER: "7"
  MAP_CLOSED_JSON: >
    {
      "tipo:interface": "Pronto - Interface",
      "tipo:integracao": "Pronto - Integração",
      "tipo:unidade": "Pronto - Unidade",
      "default": "Pronto"
    }
  MAP_OPEN_JSON: >
    {
      "default": "Em Progresso"
    }
  ADD_IF_MISSING: "true"

jobs:
  sync:
    if: startsWith(github.event.issue.title, 'EPIC:') && github.event.changes.body != null
    runs-on: ubuntu-latest
    permissions:
      issues: write
      contents: read
    concurrency:
      group: epic-sync-${{ github.event.issue.number }}
      cancel-in-progress: false

    steps:
      - name: Close/Reopen & Move in Project
        uses: actions/github-script@v7
        # se precisar usar PAT, descomente a linha abaixo e crie o secret WORKFLOW_PAT
        # with:
        #   github-token: ${{ secrets.WORKFLOW_PAT }}
        with:
          script: |
            const owner = context.repo.owner;
            const repo  = context.repo.repo;

            const before = context.payload.changes?.body?.from || '';
            const after  = context.payload.issue.body || '';

            const getChecked = (s) => {
              const re = /-\s*\[[xX]\]\s*#(\d+)/g;
              return new Set([...s.matchAll(re)].map(m => Number(m[1])));
            };

            const prev = getChecked(before);
            const curr = getChecked(after);

            const toClose = [...curr].filter(n => !prev.has(n));
            const toOpen  = [...prev].filter(n => !curr.has(n));
            const uniq = (arr) => [...new Set(arr)];

            const closedNow  = [];
            const reopenedNow = [];

            // ---- 1) Close
            for (const num of uniq(toClose)) {
              try {
                const { data } = await github.rest.issues.get({ owner, repo, issue_number: num });
                if (data.pull_request) { core.info(`#${num} é PR; ignore`); continue; }
                if (data.state !== 'closed') {
                  await github.rest.issues.update({ owner, repo, issue_number: num, state: 'closed' });
                }
                closedNow.push({ number: num, labels: (data.labels||[]).map(l => typeof l==='string'? l : l.name) });
                core.info(`Closed #${num}`);
              } catch (e) { core.warning(`Falha ao fechar #${num}: ${e.message}`); }
            }

            // ---- 2) Reopen
            for (const num of uniq(toOpen)) {
              try {
                const { data } = await github.rest.issues.get({ owner, repo, issue_number: num });
                if (data.pull_request) { core.info(`#${num} é PR; ignore`); continue; }
                if (data.state !== 'open') {
                  await github.rest.issues.update({ owner, repo, issue_number: num, state: 'open' });
                }
                reopenedNow.push({ number: num, labels: (data.labels||[]).map(l => typeof l==='string'? l : l.name) });
                core.info(`Reopened #${num}`);
              } catch (e) { core.warning(`Falha ao reabrir #${num}: ${e.message}`); }
            }

            // ---- 3) Project v2 route
            const LOGIN = (process.env.ORG || '').trim() || owner;           // usa ORG se setado, senão owner do repo
            const PROJECT_NUMBER = parseInt(process.env.PROJECT_NUMBER, 10);
            const ADD_IF_MISSING = process.env.ADD_IF_MISSING === "true";
            const MAP_CLOSED = JSON.parse(process.env.MAP_CLOSED_JSON || "{}");
            const MAP_OPEN   = JSON.parse(process.env.MAP_OPEN_JSON   || "{}");

            const pickStatus = (labels, map) => {
              for (const l of labels || []) { if (map[l]) return map[l]; }
              return map.default;
            };

            core.info(`Lookup Project: login='${LOGIN}' number=${PROJECT_NUMBER}`);

            const projQuery = `
              query($login:String!, $number:Int!) {
                organization(login:$login) {
                  projectV2(number:$number) {
                    id title
                    fields(first:50) {
                      nodes {
                        ... on ProjectV2SingleSelectField { id name options { id name } }
                      }
                    }
                  }
                }
                user(login:$login) {
                  projectV2(number:$number) {
                    id title
                    fields(first:50) {
                      nodes {
                        ... on ProjectV2SingleSelectField { id name options { id name } }
                      }
                    }
                  }
                }
              }`;

            let project;
            try {
              const r = await github.graphql(projQuery, { login: LOGIN, number: PROJECT_NUMBER });
              project = r.organization?.projectV2 ?? r.user?.projectV2;
            } catch (e) {
              core.setFailed(`Falha ao buscar Project v2 ${LOGIN}#${PROJECT_NUMBER}: ${e.message}`);
              return;
            }
            if (!project) {
              core.setFailed(
                `Project v2 '${LOGIN}#${PROJECT_NUMBER}' não encontrado/sem acesso.\n` +
                `→ Confirme que o repo ${owner}/${repo} está **linkado** ao Project (Repository → Projects → Link a project).\n` +
                `→ Ou use PAT em github-script (WORKFLOW_PAT).`
              );
              return;
            }

            core.info(`Project encontrado: ${project.title} (id: ${project.id})`);
            const statusField = project.fields.nodes.find(f => f?.name === "Status");
            if (!statusField) { core.warning(`Campo "Status" não encontrado no Project '${project.title}'`); return; }

            const findOptionId = (name) => statusField.options.find(o => o.name === name)?.id;

            const issueItemQuery = `
              query($owner:String!, $repo:String!, $num:Int!) {
                repository(owner:$owner, name:$repo) {
                  issue(number:$num) {
                    id
                    projectItems(first:50) { nodes { id project { ... on ProjectV2 { id number title } } } }
                  }
                }
              }`;
            const addItemMutation = `
              mutation($projectId:ID!, $contentId:ID!) {
                addProjectV2ItemById(input:{projectId:$projectId, contentId:$contentId}) {
                  item { id }
                }
              }`;
            const updateMutation = `
              mutation($projectId:ID!, $itemId:ID!, $fieldId:ID!, $optionId:String!) {
                updateProjectV2ItemFieldValue(input:{
                  projectId:$projectId, itemId:$itemId, fieldId:$fieldId,
                  value:{ singleSelectOptionId:$optionId }
                }) { clientMutationId }
              }`;

            const ensureItemAndSet = async (issueNumber, statusName) => {
              if (!statusName) return;
              const optionId = findOptionId(statusName);
              if (!optionId) { core.warning(`Opção "${statusName}" não existe no Status do Project '${project.title}'`); return; }

              const res = await github.graphql(issueItemQuery, { owner, repo, num: issueNumber });
              const issueId = res.repository?.issue?.id;
              let item = res.repository?.issue?.projectItems?.nodes?.find(n => n.project?.id === project.id);

              if (!item) {
                if (!ADD_IF_MISSING) { core.info(`#${issueNumber} não está no Project; ignorando update de Status`); return; }
                const added = await github.graphql(addItemMutation, { projectId: project.id, contentId: issueId });
                item = added.addProjectV2ItemById.item;
                core.info(`#${issueNumber} adicionado ao Project "${project.title}"`);
              }

              await github.graphql(updateMutation, {
                projectId: project.id,
                itemId: item.id,
                fieldId: statusField.id,
                optionId
              });
              core.info(`Status de #${issueNumber} → "${statusName}" atualizado no Project "${project.title}"`);
            };

            for (const it of closedNow) {
              const statusName = pickStatus(it.labels, MAP_CLOSED);
              await ensureItemAndSet(it.number, statusName);
            }
            for (const it of reopenedNow) {
              const statusName = pickStatus(it.labels, MAP_OPEN);
              await ensureItemAndSet(it.number, statusName);
            }
